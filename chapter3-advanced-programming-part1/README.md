# Chapter 3 - Programming Advanced - Data Structures and Algorithms

Let us first look at the definition of data structures and algorithms on Wikipedia.

> Data Structure is the way in which data is stored and organized in a computer. Often, carefully chosen data structures can lead to algorithms that are optimally efficient.

> Algorithm refers to the specific steps and methods required to complete a task. That is to say, given the initial state or input data, it is possible to derive the required or desired termination state or output data.

The algorithm and data structure are the rhetoric and layout of the program. Although human programming has only been for decades, the problems solved by the application have covered every aspect of the world. Various problems were summarized by seniors and masters. Some people directly found solutions. Some people found ways to find solutions. Some people simply proved that it is impossible to solve them at this stage. The solution is collectively referred to as an algorithm. Learning algorithms is to learn the wisdom of predecessors and to take less detours. Zen has a cloud: not taking a detour is a shortcut! ! ! Even Newton Jazz is standing on the shoulders of giants, unless you feel better than the old cows, you can solve the problems that others have been thinking for more than a decade. To illustrate this relationship more vividly, let's play a classic math game:

> There are three bottles with capacities of two liters, three liters, and seven liters. Now it is necessary to quickly and accurately measure six liters of water. How can I get it?

Obviously we have to combine these three bottles to get an accurate six liters of water. How do we get it? I think smart, you must have an answer soon. The next question is how to use the algorithm to express it? - This is testing our mathematical thinking ability. The abstraction of the problem of bottled water is actually a problem of finding the integer solution of the polynomial equation of the integral coefficient. OK, click here.

According to the definition of data structure on Wikipedia, we can compare the bottle with water on top to the data structure - the bottle is filled with water and pour water under human intervention, through three steps - your algorithm, and finally It achieved six liters of water in a seven-liter bottle. It takes six bottles of water to get six liters of water. This kind of thing is definitely not something that smart people think of, so what would a smart person think? - Finding a six-liter bottle is not a step! So sometimes it is important to find the right data structure...

The predecessors have summed up a lot of algorithms and methods to generate algorithms, we can learn directly. If you are aggressive, one day, you will find that you need to create innovative algorithms yourself. At this time, mathematics will help you a lot. Maybe just a math tool is working, but it's more likely that your brain is trained in mathematics to help you. In short, for the sake of the future, it is right to improve mathematics literacy. This is not to say that more mathematics formulas and more math problems, but rather a kind of ** mathematics thinking. **

The algorithm is very simple, it is also to find teaching materials and do exercises. Textbooks are easy to find, but novices often can't find the right exercises. You can try to do the exercises in the programming contest after completing all the exercises in the textbook, which is called [Online Judge] (http://en.wikipedia.org/wiki/Online_judge), which will be discussed in depth later. .

## Algorithm + Data Structure = Program

> *Algorithms + Data Structures = Programs* is a 1976 book written by Niklaus Wirth covering some of the fundamental topics of computer programming, particularly that algorithms and data structures are inherently related.

The basic concepts of algorithms and data structures have already been introduced above. Here, we will go a little further and further, for the novices, there is no need to entangle too much in this section. The existence of this section is for the sake of the integrity of this chapter. On the other hand, it can be used by people with a certain foundation.

In fact, the problem solved by the data structure and algorithm is the most limited and lowest-level problem in the whole programming (it does not involve design, user, etc. programming the most important second layer in the three-tier architecture). It only solves the problem that the computer supports the memory (sequencing, searching) and other limited problems in the memory of the organization. It only solves these problems well, so it is a computer-oriented functional solution. The science of computers solves the most urgent problems that computers need to solve, such as efficiency-sensitive problems. If it is discussed throughout the big programming, then it is quite a limited type of thing.

The most fundamental thing that carries computer science is the data structure and algorithms, not the language (language is just an expression tool). No wonder the grand [TAOCP] (http://en.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F% E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF) The writing is almost entirely mathematical and algorithmic analysis. Compared with the language, the language itself does not solve a problem. It is only a tool to reflect things, and there is no absolute connection with solving problems. Data structures and algorithms are the means and technology for "can really solve" computer problems. You look at the router algorithm, and these low-level things are where data structures and algorithms come into play.

Thus, when solving problems with mathematics and machine vision, it is natural to create a discipline, namely data structures and algorithms.

** Algorithms and data structures are actually solutions for discretizing application problems in the computer programming world, so that application problems can be translated into software-available abstractions, and all software problems are abstract. ** [[1]](#ref1)


## Will not break Coding?

"I can read other people's programs, but I can't write them myself, Why?" - This question is actually met by everyone who just started learning programming. You have seen such a big man. Experience, so there is no need to doubt your ability for this situation. Why is there such a situation? - Because of the mode of thinking.

In the mathematics textbooks of primary schools, there is a question type called application questions. It will give a lot of scenes in life and then let you solve it with mathematical knowledge. In solving this kind of problem, it is actually divided into three steps. The first is to extract the mathematical model. For example, the common chasing encounter problem, we must use the speed time model, then mathematically model the variable to find each variable. The relationship between the known and unknown quantities, forms a solvable equation, and finally solves.

The programming situation is similar. The first is to create an abstract description model, and then to establish a mathematical expression, the next difference is not to solve it yourself, but to give the solution method - that is, the algorithm, and finally to convert the algorithm into a program. The reason why novices usually get stuck is because there are two difficulties in this process. Building a model is not a problem, and mathematical expression is not difficult, but finding the algorithm is very difficult. Even if you find the right algorithm, it is not easy to write it into the correct code. Novices often say that I am learning XX language, XX language is really complicated. In fact, learning the language itself can only guarantee that you have fewer errors in the last step, that is, the translation code (aka coding). Even if you successfully learn 10,000 languages, you will find programming difficult, if you have not learned the algorithm. if. Let's find a concrete example to illustrate, suppose there is a problem now to find the maximum of N positive integers. Obviously the problem model is very clear, it is a mathematical problem in itself, and it does not need mathematical expression. The next step is the solution. The novice is stuck in this place.

Just taking over this topic, many people will want to use a kind of quick operation similar to humans, such as three numbers, you can find the maximum value at a glance, the four numbers are no problem, even the ten numbers are all at once. At this time, I ask you, how do you express this glance at the procedure, and what if N is greater than 10000? - Dumbless. The reason is that the human mind is too clever to handle many transactions at the same time, that is, it can process a certain amount of data in parallel (of course, large-scale data must be treated separately). And the computer - unfortunately, the ability in this area is lacking. At this time you will definitely say: "Now is there a variety of parallel processing computers such as multi-processor multi-core multi-threading?" I want to tell you that those are different levels of concept.

The computers of this era, before the revolutionary changes, are single-threaded and single-parameters from the level of CPU instructions. To put it further, these machines can only process two numbers at a time, and one of them must already be inside the CPU. Any addition of N>=3 numbers must be converted into two consecutive numbers, which is the first After adding the first and second to get the result, you can add it to the third one, and repeat all the sums as you can - this is the iron law that the current technology cannot change. At this time, I want to ask you to remember an important idea: any problem in programming should be broken down to a small enough size, so that the machine can be solved at one time! Of course, this does not mean that we have to solve the problem from the perspective of the CPU executing an instruction every time we program.

Go back to the previous question: Look for the maximum of the N positive integers. We know that direct resolution is impossible. According to the iron law just mentioned, we know that it is possible to find the maximum of the two numbers directly. How do you expand from 2 to N? Here is the world of algorithms. A very common idea is that you can find the maximum from two, and let it compare with the next one. This is the case of N=3, and then compare the maximum of the three with the fourth. This solves N=4, and so on, we seem to have found a generic algorithm. Yes, find the maximum of the first N-1 and compare it with the Nth - don't doubt that the algorithm is in the right direction. The next step is to refine it so that he can become code.

You noticed that you must first try to increase from 1 to N, and each time you do something similar, you can obviously do it with a loop. In each loop, you need to compare the maximum value of the reservation with the current nth number. If the maximum value is larger than it, then it will be retained. Otherwise, the maximum value should be replaced with a new one - this is the conditional statement. Acted. After writing this loop, there are some minor details, such as how much should this maximum be compared to the first one? If it is too big, it may be larger than the whole number of columns, which will cause problems. So the usual practice is to let him equal the first number. Then including reading the N numbers, and the trivial details of the output maximum are the finishing touches, there is nothing to talk about. Of course, even such a small problem is not only an algorithm.

You can't remember that there is a mechanism called a single elimination game - the last vertex is the maximum. It is appropriate to use in this place. However, if you want to implement this knockout algorithm into a program, how to implement grouping, how to express this elimination process and extract the value of the vertices is exactly what the algorithm description should solve. This is the most famous heap sort in the sort. <a name="sec-coding"></a> Once the algorithm (pseudocode) is fully described, programming is just a matter of typing proofreading.

Why can you read other people's programs? - Because his algorithm is implicit in the program has been implemented. Just like you read Wang Wei's poems, you can always see a beautiful landscape in front of your eyes, but it is your turn to write, but you can't paint such a picture. On the one hand, because you are helpless, you don't know how to find an achievable algorithm. On the other hand, even if you find an algorithm, you just love it in your heart and don't know how to express it.

The algorithm always starts from the problem, and gradually refines and refines it through a certain pattern until it can be directly converted into a program. It is difficult for a novice to understand what kind of algorithm is achievable at first glance, but it is not difficult to contact the novice. The algorithm is usually very clear, so the key point is to solve the problem of how to express the algorithm later. Therefore, it is recommended that novices dictate the classic example procedures in the textbook. Obviously for those examples, as long as you have seen it, you will understand its algorithm. Then, you write it again, even if it is different from its original program, it is finally expressed. Repeatedly doing this, is this expression problem not solved? And in the process, at least you learned an algorithm. Based on this principle, any routine you can understand (of course, a good routine), you are advised to dictate it - especially open source boutique code.


### Notes

1. <a name="ref1">[1]</a> This section is taken from [Algorithm + The Nature of Data Structures | 兮Soft] (http://dev.gameres.com/Program/Other/bcxszyforgameres/ Bcxszy/xisofts.sinaapp.com/@p=104.htm), the full version of the book can be found in [Programming Novice Mantra Ver3.0] (http://dev.gameres.com/Program/Other/bcxszyforgameres/bcxszy/xisofts. Sinaapp.com/@p=5.htm)