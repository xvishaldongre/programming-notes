#Chapter 1-Programming what is called

To put it simply, programming is programming (hehe, this is not nonsense...). A program is a collection of commands that make a computer function. There are basically two forms. What the computer actually performs is an electrical pulse form called a machine code, such as a binary number such as 0101. The programmer is usually written in text form called source code. The source code can be converted to machine code using a tool called a compiler/interpreter. Programming is the work of producing those source code. This work is similar to composing, compiling recipes, and writing workbooks. We know that composing and recipes are not done overnight, and often require repeated modifications until the final satisfaction, programming is the same.

## Programming Objects - Computer

Generally speaking, if the article you see is in electronic form, the thing in front of you is the computer, which is commonly known as the computer. This is enough for the average user, but the electrical engineer thinks that a bunch of boards, cables, motors, and chassis are combined. Lenovo’s salespeople think that the blocks they sell are computers. The people of the Central Military Commission probably think that the Galaxy V can be called. The programmer's opinion is not exactly the same as they are. From the programmer's point of view, as long as the thing that can be automatically calculated is the computer. The point of this statement is the automatic and computational two words. Generalized calculations refer to the ability to react to an input from the outside world, not necessarily a mathematical operation. For example, the elevator can react to the button, so it can also be calculated. Auto means that calculations are done through their own operations without external intervention.

When there is electricity, the elevator can run automatically, so it seems that the elevator is also a computer. Although the abacus can be calculated, it is not automatic, but if you count the people who plan to put it together, it is a good computer. The use of fingerprints or rainbow mode smart locks, the organs in the Mausoleum of the First Qin Emperor and the automatic piano seem to be also a type of computer. This is indeed the case, computing is everywhere, and computers are everywhere. You can even think of our world as a huge computer, and then think that we are living in Matrix. This is a very interesting philosophical question. If you are interested, check out the Matrix Trilogy. Often in practical programming, programmers only consider modern digital computers, that is, computers that use electrical energy as a power source, based on electronic circuits and logic algebras in computing. They are widely used and are extremely diverse. Mobile phones, PCs, and servers are more common. Elevators, checkout counters, and smart access control are all hidden versions. Although the external form of equipment is ever-changing, the basic principles and architecture of modern electronic computers have not changed much.

### <a name="why-binary"></a>Why use binary

From the introduction to computer courses (or other related courses), we know that in the bottom of the computer is to use binary to represent a variety of information, some people will certainly ask the bottom of the computer why not use the familiar decimal to perform various operations? Isn't this closer to human thinking habits? This idea is still good. You see how smart people are, let the computer use decimal, is it also smart? I am sorry to tell you, no, at least not at the moment, that will only drag it down. What happens when half of the people on the planet switch to Mars? The computer is called an electronic computer. Since it is based on electronic components, it has to follow the rules of the electronic world.

In digital circuits, 0 is generally used to indicate a low level, and 1 is indicated as a high level. Level is a logical quantity (a kind of thing that a smart human is defined according to its own thinking logic). It has only two values: logic high and logic low, but the logic level is represented by the magnitude of the voltage. For example, a point where the voltage difference from the negative pole of the power supply is small can be expressed as a logic low level - 0, and a point where the voltage difference is large can be expressed as a logic high level - 1. In the current circuit structure, it is easy to judge the logic high and low states, and it is cumbersome to judge more than two states.

## Why do you need programming?

The existence of programming is completely a last resort. Humans invented the computer and wanted it to do things. That's it. But the machine has three characteristics, so if you want the machine to do things, it is not as simple as telling people.

### The first feature is that the machine is silly

Many people want to be as smart as a computer. If that's the way you are finished, hurry up and get your quilt back home, but staying at the Zhuyuan Lab may be a good choice, at least with your brothers and sisters waiting for you - duty table On the tattered computer. For example, the maximum and minimum values ​​are selected from three numbers, which humans can see at a glance, but the machine can only find the largest from the two, then compare this maximum with the third, and then repeat Find the minimum value again. If it is seven eight numbers, the machine repeats this operation. Does O(∩\_∩)O\~ think of bubble sorting? This is similar to moving bricks on the construction site. The human practice moves a lot of bricks at a time. The carts or other means of transport are used to transport the bricks high and then shipped to the destination, but the computer's practice is to move only one brick per turn. You are not mistaken, every piece, one piece only 998!998, hold home! =\_= So why is the computer so powerful?

### Its second feature, fast and not messy

The machine can tirelessly repeat the same method and do something in the same way, and each repetition is quite fast. This is something that humans can't do. It may not be a problem for a person to move a pile of bricks. But a brick car can be exhausting. If there is a brick with a train skin, most people don't want to give up. Even if there is someone who insists on doing it, his movement quality will only get worse and worse. But the machine is different. He doesn't move bricks every time, but his time between back and forth is very short, such as less than 0.00...001 seconds, no matter how many bricks, 100,000, or billions. The same method of processing, neither difference nor bored until all processed. I am not afraid of suffering, not afraid of dirty, not afraid of tiredness, the model of labor in the new era! So from the overall comparison of results, the machine is stronger than people. Taking the selection of the largest and smallest numbers as an example, one can view three or four numbers with the naked eye, but more than 100 numbers use other methods. For the machine, the three and 30,000 numbers are just the difference in the number of repetitions, and the monotonous and fast repetition is the flaw of the machine. Think about what Jin Yong’s tricks are all about? ——Take the simplest tricks to the extreme, that is the trick! ! !

### More importantly, the machine and our speech are unreasonable.

That is to say, we can't raise a hand and raise an eyebrow and tell it to do things. Don't lift the bar with me and say that you can use the mouse to draw circles to let the machine do things, or you can voice control. It is no longer a pure machine. The machine and we are in different perception spaces, so it can't understand our words. We have to order it, we must use the form it can understand. Fundamentally, it is the electrical pulse - that is, the digital signal "0" and "1" as described in the section [Why use binary] (#why-binary).

Based on these three characteristics, in order for the machine to do things, we must transform our requirements into the simplest set of commands suitable for repetition, and in the form of electric pulses. For example, if we want the machine to display a picture on the screen, we first need to decompose the picture into many small squares, which are called pixels. Each pixel has only one color, and each color uses a long one. The number indicates that all of these numbers are then converted to level signals in memory, and additional circuit signals are used to send these levels one by one to the imaging circuit. All of these sets of levels and signals are programs, and programming is the job of making these programs.

Maybe one day, we no longer need to program, and the profession of programmers will no longer exist. But I think if that day comes, it is the age when the machine can fully understand human language and thought. In the scope of the naked eye, it seems that you can't see it anymore :)

## Why do you want to learn programming?

This question has two meanings. The first is programming to learn, it is very simple, because this thing is not born, just like a carpenter is a craft, it is natural to learn through learning. How do you have to spend a few years studying English? The second layer of meaning is the key point, why should I learn it? The answer naturally varies from person to person:

1. Can enhance and challenge your intelligence
3. Very interesting
4. Programming is an art
5. The general feeling of the creator

The above are all self-abuse... Let’s take a look at the following

1. Compulsory courses for the school...
2. You can make a lot of money
2. An inexplicable sense of superiority
3. Wait, etc...

In my eyes, the significance of learning programming is more about the use of modern computer technology to promote the development of the profession and society. Through the platform of computers (herein referred to as generalized computers), it is relatively convenient to realize their own ideas. It is a very good tool - "the feeling of the creator." For non-computer majors, it's also a good idea to understand the basics of programming—you can do what you want with your own hands. Modern high-level languages ​​such as Python play exceptionally cool, and the number of third-party libraries is unclear.

## Programming is what it is.

The computer itself can't do anything, and must rely on the program to direct him to do things. A program is the sequence of operational processes, or multiple operational processes that are arranged in sequence. It is a description of the method, and at the same time it often contains the idea of ​​"dividing and ruining" in "Sun Tzu's Art of War".

Long long ago, there is a man named Zhang San, a carpenter, the old man is doing furniture. Once Li Si asked him to help make a rocking chair, so Zhang San first divided the logs into wooden planks, then bent the wooden planks into the specified shape, then placed them in the appropriate position, then tried to fix them, and finally carved and polished. Painted, a beautiful rocking chair is ready. If the whole process is recorded, it is a program.

Any program has three elements, the executor, the action object (also known as the resource), and the action method (instruction). In this program of rocking the chair, Zhang San is the performer. Wood is the resource he has dealt with. Under the continuous action of the instruction, the state of the wood (resource) (such as shape size, color position, etc.) constantly changes. Finally, At the end of the program, the wood turned into a beautiful rocking chair.

The computer program is the same as above and is a description of the method. Only the executors of these programs are no longer humans, but the CPU, the commands also become CPU instructions, and the resources are things that the CPU can change its state, usually memory, of course, ports, hard disks, etc., but in general Applications can use only memory to get the job done. Sometimes I will hear people say, "My computer's memory is 500G. How can I play DOTA or is it a card?" If this kind of thing really happens on your computer, then I can only say: "Congratulations. Your computer has successfully completed the traversal. The exact production age of the computer is not prehistoric. It should be after 2014." Generally speaking, the personal computer memory does not exceed 8G, and the hard disk 500G is more common. The CPU does not read data directly from the hard disk, but indirectly through memory.

One thing to note is that the CPU does not actually know what it is doing, it is the program that commands the operation of the CPU. This is hard to understand. Let's see how the abacus is calculated.

![红木算盘](../images/suanpan.jpg)

To use an abacus, you only need one thing: mouth. Remember the cooked mouth (and of course its corresponding operation), you can use the abacus calculation. In this process of calculating with abacus, the mouth is the program that guides the calculation process. The abacus itself does not know that he is calculating. He only produces some physical changes (the change of the position of the bead). The person who does the abacus also does not need to know. He only needs to adjust the position of the bead according to the sputum. When the program ends, the bead will definitely be at a certain position. The state of this position can be read according to a certain convention and read as a certain value. For example, the following four beads are all in the middle and the beads on the top. The state that has not fallen is 4.

Devices that operate and store state do not need to know how the state is converted into information, and the conversion is done by the reader. As a very accurate example, when the display is displaying images, the display always follows the following rules:

```
Coordinates (1, 1) black, (1, 2) white, (1, 3) white, (1, 4) white, (1, 5) white, (1, 6) white, (1, 7) white, (1,8) white, (1,9) white, (1,10) black...

Coordinates (2, 1) black, (2, 2) black, (2, 3) black, (2, 4) white, (2, 5) white, (2, 6) white, (2, 7) white, (2,8) white, (2,9) white, (2,10) black...
```

Although the display only shows black or white at the appropriate coordinates, we see text, pictures and animations on the display. You don't think the monitor knows that these are Toriyama's comics? If you can make such a display, it is so talented!

The same is true for computers. For example, in the program of calculating the pi, the CPU only constantly operates on a certain block of memory. When the program ends, the memory is just in a special state. According to the prior agreement, when this state is read out, it is exactly the same as the pi, so we can say that the pi is calculated. In fact, the CPU is just a bead that moves the memory like a finger. This kind of bead is extremely simple, he only has two positions, 0 and 1, it is very convenient to toggle it, the current is OK, but there are so many beads, so that they can be combined to represent very complicated information, just like Only black and white screens can be used to represent interesting comics when there are enough screens.

So the program representative expects what the computer can do (noticing that the computer is going to do things, which has always confused many people). When people need to do these things, people provide instructions and give some resources so that the computer can Make the right changes. A program is just a description of a method. It can't be useful anymore. Until it is executed, it is given a piece of memory, telling it the accuracy of the calculation result and the storage location of the calculation result. After changing the artificially given CPU, it changes the artificially given The state of this memory is used to show the result of the calculation.

Usually, we refer to the physical part of the computer as hardware, including the circuit board, chassis, keyboard and mouse, etc., and the invisible non-physical part is called software. The software is generally the program and the data mainly generated by the program. Broadly speaking, musical scores, recipes, workbooks, and instrumental instructions are also procedures that we might call a class.

### What is the programming language?

If the above is programming, then what is the programming language (such as C language)?

The instructions for the recipes and instruments can be written in French or in Chinese without affecting the actual effect. Because humans live in the same four-dimensional physical space and time, they have the same or similar perception. Although human language is varied, it can be translated positively through translation.

Instrument operating instructions, general recipes, all described in the human world, humans can understand, so they can be described in human language. But the computer program is obviously different from the recipe, he is the command computer. First of all, the physical space that the CPU can feel is very different from the human experience. Many concepts cannot be conveyed at all. Secondly, the computer without the brain does not understand the human language. Moreover, the human language is not perfect. Many things cannot be accurately described. Therefore, human language is not qualified for this task, whether English or Chinese. This situation is somewhat similar to music, and the solution is to invent an artificial language specifically for this field. For example, the staff is a special artificial language for music use (the digital notation is also because it is quite close to the Chinese ruler spectrum, so it has been promoted to the greatest extent in China, a bit of local flavor). Then there are some specialized languages ​​that are purely used for computers.

The earliest one is based on the circuit principle. It directly uses 0 and 1 to indicate the switching of the circuit, and continuously switches the switch to form a program. This language is machine language, which can be directly understood by computers, but unfortunately, although humans can understand the language, it does not meet our usual communication habits, it is difficult to be read by people, let alone design. And modified.

Human wisdom is always infinite. Later, people proposed such a scheme. We can first generate a sequence of instructions (that is, source code) that we can understand according to some method and rule, and then pass a transformation tool (that is, compile ), turn it into an instruction that the machine can run (that is, an executable program). The sum of the rules of the instruction sequence we can understand (that is, the vocabulary and grammar [[1]] (#ref1)) is the computer language we usually say. In order to distinguish it from machine language, it is called a high-level language.

The source code in the text form at the beginning of the chapter is actually somewhat stipulated, just like we communicate with the old American in English. First of all, you have to speak English words, you can't take French vocabulary and Japanese pseudonyms. Secondly, you have to speak in grammar. You can't swear one word at a time. Programs also have vocabulary and grammatical rules that constitute a language. Obviously any programming language is an artificial language. Since it is a man-made thing, it is different because of the inventor's idea, and a different language is formed. Of course, the distinction between programming languages ​​is far more than the vocabulary and grammatical differences mentioned above, and the operating mechanism is not exactly the same.

There are many common programming languages, such as C & C++ & JAVA. The first three languages ​​have almost occupied the top three in the TIOBE programming language list in recent years. Other famous languages ​​include Python, Ruby, Perl and Golang. They have their own strengths and play their respective roles in different fields. However, because the architecture of computers is roughly the same, these languages ​​are similar and have commonalities. This situation is well understood. Usually, the real world boxing seems to be similar. Only the fantasy works such as comics will have the strange things happening when the hands and feet fly out or the mouth spits the fire.

### What is the compiler?

There are many places in the front that mention the compiler. What is it? - The code translator, which was explained more or less in the previous chapters. But I don't mind explaining it again here. Yes, as mentioned in the previous article, the program is actually a collection of instructions in the form of electrical pulses - this is absolutely correct for the machine. But do you think humans can directly operate electrical pulses? - Of course not. So at the earliest, programmers did this by repeatedly turning the switch or plugging in and out, just like the telephone operator and the dispatcher in the old movie. The following picture shows two programs for writing programs to ENIAC.

![Two programs to write programs to ENIAC] (../images/eniac4.jpg)

Later, the technology evolved. People can set the pulse signal on the punched paper tape, and then let the paper tape pass through the sensor with the light pipe. The hole circuit will pass, and it will not be broken. It is realized by the tape machine. Switch between electric pulse and paper tape. The engineers in the old movie often pick up a long piece of paper to read - really inscrutable! But even then, it is still difficult to understand the program, let alone read and modify, people are not machines. The figure below shows a standard IBM punch card with 80 columns and rectangular holes, which is equivalent to memory.

![IBM Punch Card](../images/1280px-Blue-punch-card-front-horiz.png)

In fact, the method that people are most accustomed to using to express their thoughts is words, so people envision whether they can directly write programs in the form of words. Through unremitting work, this goal has been achieved. Today, people can write a program called source code in text form, and then use a specific tool to convert the code into a form of electrical pulse that the machine can understand, that is, the target program. This conversion tool is called a compiler. It acts as a translation. It used to be a purely electromechanical device. In modern times, it has become a program.

In a way, no one can be called a programmer, and a compiler is the real programmer. What people are doing is only the source code. From this point of view, the program is actually making a program. In other words, the program is self-evolving with the help of human hands. Remember the Matrix that I said before?

Here, by the way, explain the difference between compiling and interpreting. The work of the compiler is essentially the same as translation, and we know that translation has both working modes of interpretation and translation. The programmer writes all the source code, and the compiler converts it to an executable file at one time for later execution. This translation-like mode is called compilation. Each time the programmer enters one or more lines of code, the compiler immediately converts and executes it, and then waits for the programmer's subsequent input. This way of instant interpretation is called interpretation, and the compiler is called the interpreter. . Languages ​​such as C/C++ & Pascal are compiled, and languages ​​such as Perl & Python are interpreted. The Java language is very special. It is compiled into an intermediate code and then interpreted on different machines. The platform runs, called semi-compiled mode, and Microsoft's .NET is also this mechanism. Many of the modern new interpretive languages ​​are semi-compiled – taking into account operational efficiency and cross-platformity. In general, compiled is more efficient than interpreted - because there is no need to wait for programmer input and system optimization. However, the interpreted type is easy to debug when programming, the interface is friendly, and usually the program is more convenient to write, such as Python. But no matter which language you use to program, you always need a compiler/interpreter.

Modern compilers, often more than just compilers, include code editors for shading and searching, debuggers that support single-step debugging, and multiple versions of files that can be compared and analyzed. Resource editor for control, editing icons, etc., for unified project management in large projects, and wizard tools for automated code generation. Such a compiler, we call it an integrated development environment (IDE: Integrated development environment), the representative is [open source] (http://en.wikipedia.org/wiki/%E5%BC%80%E6% 94%BE%E6%BA%90%E4%BB%A3%E7%A0%81)[Eclipse](http://en.wikipedia.org/wiki/Eclipse) and slightly softer that company's [Visual Studio] (http://en.wikipedia.org/wiki/Visual_Studio) series.

### Notes

<a name="ref1">[1]</a> For a detailed description of the language vocabulary and grammar, refer to [Basic Concepts of the Program - Natural Language and Formal Language] (http://songjinshan.com/akabook/en /intro.html#intro-naturalformallang)